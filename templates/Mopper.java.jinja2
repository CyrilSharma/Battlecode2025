{% import 'helpers/Utils.java.jinja2' as utils %}

package current;
import battlecode.common.*;

public class Mopper {
    public static RobotController rc;
    public static MapLocation buildTower = null;
    public static MapLocation myloc;
    public static int paintCapacity = UnitType.SOLDIER.paintCapacity;
    public static int myPaint;
    public static MapLocation exploreTarget;
    public static MapInfo[] near;
    public static MapLocation ruinLoc;
    public static boolean[][] resourcePat = null;
    public static boolean shouldGoHome = false;

    public static void init(RobotController rc) {
        Mopper.rc = rc;
    }

    public static boolean canMop(MapInfo mi) throws GameActionException {
        return (!mi.getPaint().isAlly() && mi.getPaint() != PaintType.EMPTY);
    }

    public static MapLocation seeRuin() throws GameActionException {
        for (int i = near.length; --i >= 0; ) {
            if (near[i].hasRuin()) {
                RobotInfo r = rc.senseRobotAtLocation(near[i].getMapLocation());
                if (r == null) {
                    return near[i].getMapLocation();
                }
            }
        }
        return null;
    }

    public static void makeTower() throws GameActionException {
        assert(buildTower != null);
        MapLocation tmp;
        MapLocation goal = null;
        int bestDist = 1000000000;
        {% for i in range(2, -3, -1) %}
        {% for j in range(2, -3, -1) %}
        {% if i != 0 or j != 0 %}
        tmp = new MapLocation(buildTower.x + {{i}}, buildTower.y + {{j}});
        if (rc.canSenseLocation(tmp)) {
            MapInfo mi = rc.senseMapInfo(tmp);
            switch (mi.getPaint()) {
                case ENEMY_SECONDARY, ENEMY_PRIMARY -> {
                    int d = rc.getLocation().distanceSquaredTo(tmp);
                    if (d < bestDist) {
                        bestDist = d;
                        goal = tmp;
                    }
                }
            }
        }
        {% endif %}
        {% endfor %}
        {% endfor %}

        if (goal != null) {
            if (rc.canAttack(goal)) {
                rc.attack(goal);
            }
            else {
                Pathing.pathTo(goal);
            }
        }
        else {
            if (rc.canCompleteTowerPattern(UnitType.LEVEL_ONE_PAINT_TOWER, buildTower)) {
                rc.completeTowerPattern(UnitType.LEVEL_ONE_PAINT_TOWER, buildTower);
            }
            if (rc.canCompleteTowerPattern(UnitType.LEVEL_ONE_MONEY_TOWER, buildTower)) {
                rc.completeTowerPattern(UnitType.LEVEL_ONE_MONEY_TOWER, buildTower);
            }
            Pathing.pathTo(buildTower);
        }
    }

    public static boolean isBuilt(MapLocation ruinLoc) throws GameActionException {
        if (rc.canSenseLocation(ruinLoc)) {
            RobotInfo r = rc.senseRobotAtLocation(ruinLoc);
            return (r != null);
        }
        return false;
    }

    public static boolean mopSquares() throws GameActionException {
        if (rc.getPaint() < 20) return false;
        MapLocation goal = null;
        MapLocation secondGoal = null;
        int bestDist = 1000000000;
        int secondDist = 1000000000;
        for (int i = near.length; --i >= 0; ) {
            int d = rc.getLocation().distanceSquaredTo(near[i].getMapLocation());
            if (near[i].getMark() != PaintType.EMPTY && near[i].getMark() != near[i].getPaint() && canMop(near[i])) {
                if (d < bestDist) {
                    bestDist = d;
                    goal = near[i].getMapLocation();
                }
            }
            if (canMop(near[i])) {
                if (d < secondDist) {
                    secondGoal = near[i].getMapLocation();
                    secondDist = d;
                }
            }
        }
        if (goal != null) {
            if (rc.canAttack(goal)) {
                rc.attack(goal);
            }
            else {
                Pathing.pathTo(goal);
            }
            return true;
        }
        else if (secondGoal != null) {
            if (rc.canAttack(secondGoal)) {
                rc.attack(secondGoal);
            }
            else {
                Pathing.pathTo(secondGoal);
            }
            return true;
        }
        return false;
    }

    public static void run() throws GameActionException {
        near = rc.senseNearbyMapInfos();
        if (resourcePat == null) resourcePat = rc.getResourcePattern();

        RefuelManager.setHome();
        boolean lowHealth = (myPaint <= (paintCapacity >> 2));
        if (lowHealth != shouldGoHome) {
            shouldGoHome = lowHealth;
            RefuelManager.reset();
        }

        myloc = rc.getLocation();
        myPaint = rc.getPaint();

        if (shouldGoHome) { 
            rc.setIndicatorString("Refueling");
            RefuelManager.refuel();
            return;
        }
        else if (Attack.shouldMopperMicro()) {
            rc.setIndicatorString("Mopping");
            Attack.mopperAttackMicro();
            return;
        }
        else if (rc.getNumberTowers() < 25){
            buildTower = null;
            ruinLoc = seeRuin();
            if (ruinLoc != null) {
                boolean incRuin = Globals.seeIncompleteRuin(ruinLoc);

                if (incRuin){
                    buildTower = ruinLoc;
                }

                if (buildTower != null) {
                    makeTower();
                }
            }
        }
        
        if(!mopSquares()) Explore.exploreOnPaint(near);
    }
}