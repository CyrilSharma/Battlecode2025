package current;
import battlecode.common.*;

public class SquareManager {
    public static RobotController rc;
    public static void init(RobotController rc) {
        SquareManager.rc = rc;
    } 

    public static MapLocation myloc = null;

    {% set OFFSET = SQUARE_OFFSET %}
    {% for di in range(-OFFSET, OFFSET + 1) %}
    {% for dj in range(-OFFSET, OFFSET + 1) %}
    {% set i = di + OFFSET %}
    {% set j = dj + OFFSET %}
    public static MapLocation m{{i}}{{j}} = null;
    public static boolean canSense{{i}}{{j}} = false;
    public static MapInfo info{{i}}{{j}} = null;
    public static RobotInfo r{{i}}{{j}} = null;
    public static boolean friend{{i}}{{j}} = false;
    public static int penalty{{i}}{{j}} = 0;
    public static int adjacent{{i}}{{j}} = 0;
    {% endfor %}
    {% endfor %}

    public static void run() throws GameActionException {
        myloc = rc.getLocation();
        loadSquaresDone = false;
        computeAllyAdjacencyDone = false;
        computePaintPenaltiesDone = false;
    }

    public static boolean loadSquaresDone = false;
    public static void loadSquares() throws GameActionException {
        if (loadSquaresDone) return;
        int used = Clock.getBytecodeNum();
        {% for di in range(-OFFSET, OFFSET + 1) %}
        {% for dj in range(-OFFSET, OFFSET + 1) %}
        {% set i = squareOffset(di) %}
        {% set j = squareOffset(dj) %}
        m{{i}}{{j}} = new MapLocation(myloc.x + {{di}}, myloc.y + {{dj}});
        canSense{{i}}{{j}} = rc.canSenseLocation(m{{i}}{{j}});
        if (canSense{{i}}{{j}}) {
            info{{i}}{{j}} = rc.senseMapInfo(m{{i}}{{j}}); 
            r{{i}}{{j}} = rc.senseRobotAtLocation(m{{i}}{{j}});
            friend{{i}}{{j}} = (r{{i}}{{j}} != null) ? r{{i}}{{j}}.team == rc.getTeam() : false;
        } else {
            info{{i}}{{j}} = null; 
            r{{i}}{{j}} = null;
            friend{{i}}{{j}} = false;
        }
        {% endfor %}
        {% endfor %}
        System.out.println("Total: " + (used - Clock.getBytecodeNum()));
        loadSquaresDone = true;
    }

    public static boolean computeAllyAdjacencyDone = false;
    public static void computeAllyAdjacency() throws GameActionException {
        if (computeAllyAdjacencyDone) return;
        loadSquares();
        {% for di in range(-1, 2) %}
        {% for dj in range(-1, 2) %}
        {   
            adjacent{{squareOffset(di)}}{{squareOffset(dj)}} = 0;
            {% for dk in range(-1, 2) %}
            {% for dl in range(-1, 2) %}
            {% if (di + dk) != 0 or (dj + dl) != 0 %}
            if (friend{{squareOffset(di+dk)}}{{squareOffset(dj+dl)}}) 
                ++adjacent{{squareOffset(di)}}{{squareOffset(dj)}};
            {% endif %}
            {% endfor %}
            {% endfor %}
        }
        {% endfor %}
        {% endfor %}
        computeAllyAdjacencyDone = true;
    }

    public static boolean computePaintPenaltiesDone = false;
    public static void computePaintPenalties() throws GameActionException {
        if (computePaintPenaltiesDone) return;
        computeAllyAdjacency();
        {% for di in range(-1, 2) %}
        {% for dj in range(-1, 2) %}
        {
            {% set i = squareOffset(di) %}
            {% set j = squareOffset(dj) %}
            if (canSense{{i}}{{j}}) {
                penalty{{i}}{{j}} = switch (info{{i}}{{j}}.getPaint()) {
                    case ENEMY_PRIMARY, ENEMY_SECONDARY -> 2 + 2 * adjacent{{i}}{{j}};
                    case ALLY_PRIMARY, ALLY_SECONDARY -> adjacent{{i}}{{j}};
                    case EMPTY -> 1 + adjacent{{i}}{{j}};
                };
            }
        }
        {% endfor %}
        {% endfor %}
        computePaintPenaltiesDone = true;
    }
}