
{% import 'helpers/Utils.java.jinja2' as utils %}

package current;
import battlecode.common.*;

public class Tower {
    public static RobotController rc;
    public static MapLocation myloc;
    public static boolean shouldDefend;
    public static int lastDefenseRound = -100;
    public static final int defenseWaitRounds = 30;
    public static UnitType unitToBuild = null;
    public static int enemyLastSeen = 0;
    public static boolean isPaintTower = false;
    public static boolean isMoneyTower = false;
    public static void init(RobotController rc) {
        Tower.rc = rc;
        enemyLastSeen = rc.getRoundNum();
        switch(rc.getType()) {
            case LEVEL_ONE_MONEY_TOWER, LEVEL_TWO_MONEY_TOWER, LEVEL_THREE_MONEY_TOWER -> isMoneyTower = true;
            case LEVEL_ONE_PAINT_TOWER, LEVEL_TWO_PAINT_TOWER, LEVEL_THREE_PAINT_TOWER -> isPaintTower = true;
            default -> {}
        }
    }

    public static void run() throws GameActionException {
        initTurn();
        runTurn();
    }

    
    public static void initTurn() throws GameActionException {
        myloc = rc.getLocation();
        shouldDefend = false;
        boolean threatInRange = false;
        for (RobotInfo r: Globals.enemies) {
            switch (r.type) {
                case SOLDIER, SPLASHER: {
                    threatInRange = true;
                    break;
                }
                default: continue;
            }
        }

        int friendlyMoppersInRange = 0;
        for (RobotInfo r: Globals.friends) {
            switch (r.type) {
                case MOPPER: ++friendlyMoppersInRange;
                default: continue;
            }
        }

        if ((threatInRange && (friendlyMoppersInRange < 2))
         && ((rc.getRoundNum() - lastDefenseRound >= defenseWaitRounds) || (isPaintTower))) {
            shouldDefend = true;
            lastDefenseRound = rc.getRoundNum();
        }
    }

    public static int soldiersBuilt = 0;
    public static int splashersBuilt = 0;
    public static int moppersBuilt = 0;
    public static UnitType getUnitType() throws GameActionException {
        // Early Game Spawning Logic.
        if (rc.getRoundNum() < 5) return UnitType.SOLDIER;
        
        // If have already select a unit, stick with that.
        if (unitToBuild != null && isPaintTower) return unitToBuild;
        
        // If we've selected a unit, but we're low on paint now, make a mopper
        else if (unitToBuild != null && !isPaintTower && (rc.getPaint() < 200))
            return UnitType.MOPPER;
        
        
        int money = rc.getMoney();

        // Paint Tower Spawning Logic.
        if (isPaintTower) {
            if (money < 2000 && Globals.getIncome() < 80) {
                // Mantain 3-2 ratio soldiers - moppers when we're trying to grow.
                if (2 * soldiersBuilt <= 3 * moppersBuilt) return UnitType.SOLDIER;
                else return UnitType.MOPPER;
            } else {
                // Mantain 2-2-1 ratio splashsers - soldiers - moppers when we're rich.
                if ((splashersBuilt <= 2 * moppersBuilt) && (splashersBuilt <= soldiersBuilt)) {
                    return UnitType.SPLASHER;
                } else if ((soldiersBuilt <= 2 * moppersBuilt) && (soldiersBuilt < splashersBuilt)) {
                    return UnitType.SOLDIER;
                } else {
                    return UnitType.MOPPER;
                }
            }
        }

        // Money Tower Spawning Logic.
        else if (!isPaintTower) {
            if (rc.getPaint() < 200) {
                // We don't have enough paint to make anything else.
                return UnitType.MOPPER;
            } else if (money < 2000 && Globals.getIncome() < 80) {
                // Produce 2 soldiers and 1 Mopper.
                if (moppersBuilt == 1) return UnitType.SOLDIER;
                else if (soldiersBuilt < 2) return UnitType.SOLDIER;
                else return UnitType.MOPPER;
            } else {
                // Produce 1 splasher and 1 Soldier.
                if (splashersBuilt == 0) return UnitType.SPLASHER;
                else return UnitType.SOLDIER;
            } 
        }
        
        return null;
    }


    public static void runTurn() throws GameActionException {
        towerTryAttack();
        towerTryUpgrade();
        unitToBuild = getUnitType(); 
        rc.setIndicatorString(
            "PaintTower=" + isPaintTower + " - Saving for " + unitToBuild + "\n" + 
            " s=" + soldiersBuilt + " sp=" + splashersBuilt + " mp=" + moppersBuilt);
        if (unitToBuild == null) return;
        if (rc.getPaint() < unitToBuild.paintCost) return;
        
        // This prevents us from spending so much that we start mitigating expansion.
        if (!shouldDefend) {
            int lim = 10;
            if (rc.getMapHeight() * rc.getMapWidth() <= 600) lim = 50;
            if (rc.getRoundNum() > lim) {
                if (rc.getMoney() < 1250) return;
            }
        }
        

        // Defense. We put this as an override to avoid deciding to make a mopper,
        // The threat goes away, but we make a mopper anyways.
        UnitType t = (shouldDefend) ? (UnitType.MOPPER) : (unitToBuild);
        loop: {
        {%- for direction in directions %}
        {
            MapLocation nextLoc = myloc.add({{ direction }});
            if (rc.canBuildRobot(t, nextLoc)) {
                rc.buildRobot(t, nextLoc);
                switch (t) {
                    case SOLDIER -> ++soldiersBuilt;
                    case SPLASHER -> ++splashersBuilt;
                    case MOPPER -> ++moppersBuilt;
                    default -> {}
                }
                unitToBuild = null;
                break loop;
            }
        }
        {% endfor -%}
        }
    }

    public static void towerTryUpgrade() throws GameActionException {
        if (Globals.enemies.length > 0)
            enemyLastSeen = rc.getRoundNum();
        if ((rc.getType() == UnitType.LEVEL_ONE_PAINT_TOWER)
            && (rc.getMoney() >= (UnitType.LEVEL_TWO_PAINT_TOWER.moneyCost + 1000))
            && (rc.getRoundNum() - enemyLastSeen >= 10)) {
            rc.upgradeTower(rc.getLocation());
        } else if ((rc.getType() == UnitType.LEVEL_TWO_PAINT_TOWER)
            && (rc.getMoney() >= (UnitType.LEVEL_THREE_PAINT_TOWER.moneyCost + 1000))
            && (rc.getRoundNum() - enemyLastSeen >= 10)) {
            rc.upgradeTower(rc.getLocation());
        }
    }

    public static void towerTryAttack() throws GameActionException {
        MapLocation bestSplasherLoc = null;
        int smallestSplasherHealth = 100000000;
        MapLocation bestSoldierLoc = null;
        int smallestSoldierHealth = 100000000;
        MapLocation bestNonSoldierLoc = null;
        int smallestNonSoldierHealth = 10000000;
        for (int i = Globals.enemies.length; --i >= 0;) {
            RobotInfo enemy = Globals.enemies[i];
            if (enemy.paintAmount == 0) continue;
            MapLocation loc = enemy.location;
            if (rc.canAttack(loc)) {
                switch (enemy.type) {
                    case SPLASHER -> {
                        if (enemy.health < smallestSplasherHealth) {
                            bestSplasherLoc = loc;
                            smallestSplasherHealth = enemy.health;
                        }
                    }
                    case SOLDIER -> {
                        if (enemy.health < smallestSoldierHealth) {
                            bestSoldierLoc = loc;
                            smallestSoldierHealth = enemy.health;
                        }
                    }
                    default -> {
                        if (enemy.health < smallestNonSoldierHealth) {
                            bestNonSoldierLoc = loc;
                            smallestNonSoldierHealth = enemy.health;
                        }
                    }
                }
                
            }
        }

        if (bestSplasherLoc != null) {
            rc.setIndicatorDot(bestSplasherLoc, 0, 0, 0);
            rc.attack(bestSplasherLoc);
        }  else if (bestSoldierLoc != null) {
            rc.setIndicatorDot(bestSoldierLoc, 0, 0, 0);
            rc.attack(bestSoldierLoc);
        } else if (bestNonSoldierLoc != null) {
            rc.setIndicatorDot(bestNonSoldierLoc, 0, 0, 0);
            rc.attack(bestNonSoldierLoc);
        }

        if (rc.canAttack(null)) rc.attack(null);
    }
}