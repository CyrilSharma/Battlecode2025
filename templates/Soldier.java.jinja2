{% import 'helpers/Utils.java.jinja2' as utils %}

package current;
import battlecode.common.*;
import java.util.ArrayList;
import java.util.Collections;

public class Soldier {
    public static RobotController rc;
    public static boolean homeHasPaint = false;
    public static MapLocation buildTower = null;
    public static MapLocation myloc;
    public static int paintCapacity = UnitType.SOLDIER.paintCapacity;
    public static int myPaint;
    public static MapLocation exploreTarget;
    public static MapInfo[] near;
    public static MapLocation ruinLoc;
    public static MapLocation markedResource = null;
    public static boolean[][] resourcePat = null;
    public static boolean shouldGoHome = false;
    public static boolean moved = false;
    public static MapLocation returnLoc = null;

    public static MapLocation chunkGoal = null;

    public static int[] dy = {0, 0, 4, -4};
    public static int[] dx = {-4, 4, 0, 0};

    public static void init(RobotController rc) {
        Soldier.rc = rc;
        resourcePat = rc.getResourcePattern();
    }

    public static boolean shouldUseSecond(MapLocation loc, MapLocation center) throws GameActionException {
        return resourcePat[2 + (loc.x - center.x)][2 + (loc.y - center.y)];
    }

    public static boolean okToTile(MapLocation m) throws GameActionException {
        if (rc.getNumberTowers() == 25) return true;
        if (rc.canSenseLocation(m)) {
            MapInfo mc = rc.senseMapInfo(m);
            if (mc.getPaint() != PaintType.EMPTY) return false;
        }
        for (int i = 3; --i >= -2; ){
            for (int j = 3; --j >= -2; ){
                if (i == 0 && j == 0) continue;
                MapLocation tmp = new MapLocation(m.x + i, m.y + j);
                if (rc.canSenseLocation(tmp)) {
                    MapInfo mi = rc.senseMapInfo(tmp);
                    if (mi.hasRuin()) {
                        RobotInfo r = rc.senseRobotAtLocation(tmp);
                        if (r == null) return false;
                    }
                }
            }
        }
        return true;
    }

    public static void checkMoneyPatterns() throws GameActionException {
        MapLocation tmp;
        {% for i in range(2, -3, -1) %}
        {% for j in range(2, -3, -1) %}
        {% if i != 0 or j != 0 %}
        tmp = new MapLocation(myloc.x + {{i}}, myloc.y + {{j}});
        if (rc.canSenseLocation(tmp)) {
            MapInfo mi = rc.senseMapInfo(tmp);
            if (mi.getMark() == PaintType.ALLY_PRIMARY) {
                if (rc.canCompleteResourcePattern(tmp)) {
                    rc.completeResourcePattern(tmp);
                    return;
                }
            }
        }
        {% endif %}
        {% endfor %}
        {% endfor %}
    }

    public static boolean canChangeColor(MapInfo mi) throws GameActionException {
        return (mi.getPaint().isAlly() || mi.getPaint() == PaintType.EMPTY);
    }

    public static boolean canChangeColor(MapLocation m) throws GameActionException {
        if (!rc.canSenseLocation(m)) return false;
        MapInfo mi = rc.senseMapInfo(m);
        return canChangeColor(mi);
    }

    public static boolean visited(MapLocation m) throws GameActionException {
       switch (m.y) {
            {% for y in range(0, 60) -%}
            case {{ y }} -> {
                return ((TileLoader.visited{{ y }} >> m.x) & 1) == 1;
            }
            {% endfor -%}
        } 
        return false;
    }

    public static boolean isOk(MapLocation p, MapLocation q) throws GameActionException {
        MapLocation tmp;
        {% for i in range(2, -3, -1) %}
        {% for j in range(2, -3, -1) %}
        tmp = new MapLocation(q.x + {{i}}, q.y + {{j}});
        if (rc.canSenseLocation(tmp)) {
            if (tmp.distanceSquaredTo(p) <= 8) {
                if (shouldUseSecond(tmp, p) != shouldUseSecond(tmp, q)) return false;
            }
        }
        {% endfor %}
        {% endfor %}
        return true;
    }

    public static void moneyPattern() throws GameActionException {
        if (markedResource != null) return;
        if (!(rc.getNumberTowers() > 2 || rc.getRoundNum() > 100)) return;

        if (chunkGoal != null) {
            if (myloc.equals(chunkGoal)) chunkGoal = null;
            else Pathing.pathTo(chunkGoal);
        }

        //this just checks that nothing is like directly in the way
        for (int i = 3; --i >= -2; ){
            for (int j = 3; --j >= -2; ){
                MapLocation tmp = new MapLocation(myloc.x + i, myloc.y + j);
                if (rc.canSenseLocation(tmp)) {
                    MapInfo mi = rc.senseMapInfo(tmp);
                    if (!mi.isPassable()) {
                        return;
                    }
                    if (!mi.getPaint().isAlly() && mi.getPaint() != PaintType.EMPTY) return;
                    if (mi.isResourcePatternCenter()) return;
                    RobotInfo r = rc.senseRobotAtLocation(tmp);
                    if (r != null && Globals.isTower(r.getType())) {
                        return;
                    }
                }
                else {
                    return;
                }
            }
        }

        // ok there is probably better way to do this with bitmasks or something but ill just do this for now...
        for (int i = near.length; --i >= 0; ) {
            if (near[i].getMark() == PaintType.ALLY_PRIMARY) {
                if (!isOk(near[i].getMapLocation(), myloc)) return;
            }
        }

        if (rc.canMark(myloc)) {
            rc.mark(myloc, false);
            markedResource = myloc;
        }
    }

    public static boolean okSRP(MapLocation loc) throws GameActionException {
        MapLocation tmp;
        {% for i in range(2, -3, -1) %}
        {% for j in range(2, -3, -1) %}
        tmp = new MapLocation(loc.x + {{i}}, loc.y + {{j}});
        if (!Globals.onMap(tmp)) return false;
        if (rc.canSenseLocation(tmp)) {
            MapInfo mi = rc.senseMapInfo(tmp);
            if (!mi.isPassable()) return false;
            if (!mi.getPaint().isAlly() && mi.getPaint() != PaintType.EMPTY) return false;
        }
        {% endfor %}
        {% endfor %}
        return true;
    }

    public static MapLocation findNext(MapLocation m) throws GameActionException {
        int st = Globals.rng.nextInt(4);
        MapLocation tmp;
        MapInfo mi;
        {% for i in range(4) %}
        tmp = new MapLocation(m.x + dx[(st + {{i}}) % 4], m.y + dy[(st + {{i}}) % 4]);
        mi = rc.senseMapInfo(tmp);
        if (okSRP(tmp) && mi.getMark() != PaintType.ALLY_PRIMARY) {
            return tmp;
        }
        {% endfor %}
        return null;
    }

    public static void makeResourcePatch() throws GameActionException {
        //TODO: if we see a conflict, stop building and mark with a 2 (can add later)
        if (!rc.getLocation().equals(markedResource)) Pathing.pathTo(markedResource);
        moved = true;
        MapLocation goal = null;
        int bestDist = 1000000000;
        boolean secondCol = false;
        for (int i = 3; --i >= -2; ){
            for (int j = 3; --j >= -2; ){
                MapLocation tmp = new MapLocation(markedResource.x + i, markedResource.y + j);
                if (rc.canSenseLocation(tmp)) {
                    MapInfo mi = rc.senseMapInfo(tmp);
                    if (canChangeColor(mi)) {
                        boolean b = shouldUseSecond(tmp, markedResource);
                        if (mi.getPaint().isAlly()) {
                            if (b == (mi.getPaint() == PaintType.ALLY_SECONDARY)) {
                                continue;
                            }
                        }
                        int d = rc.getLocation().distanceSquaredTo(tmp);
                        if (d < bestDist) {
                            bestDist = d;
                            goal = tmp;
                            secondCol = b;
                        }
                    }
                }
            }
        }
        if (goal != null) {
            if (rc.canAttack(goal)) {
                rc.attack(goal, secondCol);
            }
            if (rc.canCompleteResourcePattern(markedResource)) {
                rc.completeResourcePattern(markedResource);
                markedResource = null;
                chunkGoal = findNext(myloc);
            }
            MapInfo mi = rc.senseMapInfo(myloc);
            if (mi.isResourcePatternCenter()) {
                markedResource = null;
                chunkGoal = findNext(myloc);
            }
        }
        else {
            if (rc.canCompleteResourcePattern(markedResource)) {
                rc.completeResourcePattern(markedResource);
                chunkGoal = findNext(myloc);
            }
            markedResource = null;
        }
    }

    public static void run() throws GameActionException {
        initTurn();
        runTurn();
        postTurn();
    }

    public static void initTurn() throws GameActionException {
        near = rc.senseNearbyMapInfos();
        myloc = rc.getLocation();
        myPaint = rc.getPaint();
        moved = false;

        RefuelManager.setHome();
        boolean lowHealth = (myPaint <= (paintCapacity >> 2));
        if (lowHealth != shouldGoHome) {
            shouldGoHome = lowHealth;
            if (buildTower != null && shouldGoHome) returnLoc = buildTower;
            RefuelManager.reset();
        }
    }


    public static boolean getGoodColor(MapLocation m) throws GameActionException {
        MapLocation tmp;
        {% for i in range(2, -3, -1) %}
        {% for j in range(2, -3, -1) %}
        tmp = new MapLocation(m.x + {{i}}, m.y + {{j}});
        if (rc.canSenseLocation(tmp)) {
            MapInfo mi = rc.senseMapInfo(tmp);
            if (mi.getMark() == PaintType.ALLY_PRIMARY) {
                return Soldier.shouldUseSecond(m, tmp);
            }
        }
        {% endfor %}
        {% endfor %}
        return false;
    }

    public static boolean checkNearby(MapLocation loc) throws GameActionException {
        MapLocation tmp;
        {% for i in range(2, -3, -1) %}
        {% for j in range(2, -3, -1) %}
        {% if i != 0 or j != 0 %}
        tmp = new MapLocation(loc.x + {{i}}, loc.y + {{j}});
        if (rc.canSenseLocation(tmp)) {
            MapInfo mi = rc.senseMapInfo(tmp);
            boolean b = shouldUseSecond(tmp, loc);
            if (mi.getPaint() == PaintType.EMPTY || (mi.getPaint().isAlly() && b != (mi.getPaint() == PaintType.ALLY_SECONDARY))) {
                if (rc.canAttack(tmp)) {
                    rc.attack(tmp, b);
                    return true;
                }
            }
        }
        {% endif %}
        {% endfor %}
        {% endfor %}
        return false;
    }

    public static void helpPattern(MapInfo[] near) throws GameActionException {
        for (int i = near.length; --i >= 0;) {
            if (near[i].getMark() == PaintType.ALLY_PRIMARY) {
                if (checkNearby(near[i].getMapLocation())) return;
            }
        }
    }
    
    public static void runTurn() throws GameActionException {
        if (rc.getNumberTowers() < 25 && rc.getPaint() < 50) {
            buildTower = TowerBuild.getRuin(near);
            if (buildTower != null && TowerBuild.enoughPaint(buildTower)) {
                TowerBuild.makeTower(buildTower);
                return;
            }
        }

        if (shouldGoHome) {
            rc.setIndicatorString("Refueling");
            RefuelManager.refuel();
            return;
        } else if (Attack.shouldSoldierMicro()) {
            rc.setIndicatorString("Attacking");
            Attack.soldierAttackMicro();
            return;
        } else if (rc.getNumberTowers() < 25 && markedResource == null) {
            buildTower = TowerBuild.getRuin(near);
            if (buildTower != null) {
                TowerBuild.makeTower(buildTower);
                return;
            }
        }

        if (returnLoc != null) {
            if (myloc.distanceSquaredTo(returnLoc) <= 5) {
                returnLoc = null;
            }
            else {
                Pathing.pathTo(returnLoc);
            }
        }

        moneyPattern();
        if (markedResource != null) {
            rc.setIndicatorString("Patching Resource");
            makeResourcePatch();
            return;
        }

        helpPattern(near);

        if (moved) return;

        //rc.setIndicatorString("Exploring");
        Explore.explore(near);
    }

    public static void postTurn() throws GameActionException {

        // Lay paint where I am first.
        if (canChangeColor(myloc) && rc.canAttack(myloc) && rc.getPaint() >= 50 && okToTile(myloc)){
            rc.attack(myloc, getGoodColor(myloc));
        }

        if (buildTower != null && !Globals.shouldStallForIncome()) {
            if (rc.canCompleteTowerPattern(UnitType.LEVEL_ONE_PAINT_TOWER, buildTower)) {
                rc.completeTowerPattern(UnitType.LEVEL_ONE_PAINT_TOWER, buildTower);
            }
            if (rc.canCompleteTowerPattern(UnitType.LEVEL_ONE_MONEY_TOWER, buildTower)) {
                rc.completeTowerPattern(UnitType.LEVEL_ONE_MONEY_TOWER, buildTower);
            }
        }
        checkMoneyPatterns();
    }
}