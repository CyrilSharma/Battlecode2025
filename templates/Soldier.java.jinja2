{% import 'helpers/Utils.java.jinja2' as utils %}

package current;
import battlecode.common.*;

public class Soldier {
    public static RobotController rc;
    public static MapLocation home = null;
    public static final int paintCapacity = UnitType.SOLDIER.paintCapacity;
    public static int myPaint;
    public static MapInfo[] near;
    public static MapLocation ruinLoc;
    public static MapLocation markedResource = null;
    public static MapLocation removing = null;
    public static int removeMask = 0;
    public static boolean[][] resourcePat = null;

    public static MapLocation buildTower = null;
    public static boolean patternLaid = false;
    public static int buildExploreTurns = 0;

    public static void init(RobotController rc) {
        Soldier.rc = rc;
    }

    public static void run() throws GameActionException {
        initTurn();
        runTurn();
        postTurn();
    }

    public static void initTurn() throws GameActionException {
        rc.setIndicatorString("Undefined");
        setHome();
        if (resourcePat == null) resourcePat = rc.getResourcePattern();
        myPaint = rc.getPaint();
        near = rc.senseNearbyMapInfos(-1);
        updateBuild();
    }

    public static void runTurn() throws GameActionException {
        boolean shouldGoHome = (myPaint <= (paintCapacity >> 2));
        boolean canBuild = rc.getNumberTowers() < 25;
        // If not building a money pattern, and not removing a resource. 
        // boolean canGetDistracted = (patternLaid && rc.getMoney() < 1000); // false 
        // && (markedResource == null && removing == null)


        
        // boolean canGetDistracted = (patternLad && rc.getMoney() < 200 && rc.getNumberTowers() < 5) 
        
        // If we're really low on money, just go somewhere else. 
        // But only if this is a common area, where someone else will find it.
        {# RobotInfo[] friends = rc.senseNearbyRobots(9, rc.getTeam());
        if (friends.length >= 1) resetBuild(); #}
        {# if (rc.getMoney() < 200) {
            // But only if this is a common area, where someone else will find it.
            RobotInfo[] friends = rc.senseNearbyRobots(9, rc.getTeam());
            if (friends.length >= 1) resetBuild();
        } #}

        boolean shouldBuild = (canBuild) && (buildTower != null);
        {# {% debug('canGetDistracted', 'shouldBuild', 'patternLaid') %} #}
        if (shouldGoHome && home != null) {
            rc.setIndicatorString("Refueling");
            refuel();
        } else if (shouldGoHome && home == null) {
            rc.setIndicatorString("Exploring");
            Explore.exploreOnPaint(near);
        } else if (shouldBuild) {
            rc.setIndicatorString("Building (" + buildTower.x + ", " + buildTower.y + ")");
            makeTower();
        } else if (markedResource != null) {
            rc.setIndicatorString("Making Resource");
            makeResourcePatch();
        } else if (removing != null) {
            rc.setIndicatorString("Removing Pattern");
            removePattern();
        } else {
            rc.setIndicatorString("Money Pattern");
            moneyPattern();
            if (!paintMarkedSquares()) {
                Explore.explore(near);
                rc.setIndicatorString("Also Exploring: " + Explore.exploreTarget.x + " " + Explore.exploreTarget.y);
            }
        }
    }


    public static void postTurn() throws GameActionException {
        MapLocation myloc = rc.getLocation();
        MapInfo currentTile = rc.senseMapInfo(myloc);
        if (!currentTile.getPaint().isAlly() && rc.canAttack(myloc)){
            rc.attack(myloc);
        }
    }

    // TODO: Make this a switch.
    public static boolean isTower(UnitType u) {
        return (u == UnitType.LEVEL_ONE_PAINT_TOWER ||
                u == UnitType.LEVEL_ONE_MONEY_TOWER ||
                u == UnitType.LEVEL_ONE_DEFENSE_TOWER ||
                u == UnitType.LEVEL_TWO_PAINT_TOWER ||
                u == UnitType.LEVEL_TWO_MONEY_TOWER ||
                u == UnitType.LEVEL_TWO_DEFENSE_TOWER ||
                u == UnitType.LEVEL_THREE_PAINT_TOWER ||
                u == UnitType.LEVEL_THREE_MONEY_TOWER ||
                u == UnitType.LEVEL_THREE_DEFENSE_TOWER);
    }

    public static boolean canChangeColor(MapInfo mi) throws GameActionException {
        return (mi.getPaint().isAlly() || mi.getPaint() == PaintType.EMPTY);
    }

    public static void setHome() throws GameActionException {
        if (home != null) {
            //if we can see it, it is not a paint tower, and it is empty - set to null
            if (rc.canSenseLocation(home)) {
                RobotInfo r = rc.senseRobotAtLocation(home);
                if (r == null || r.paintAmount == 0) {
                    home = null;
                }
            }

        }
        RobotInfo[] robots = rc.senseNearbyRobots();
        RobotInfo robot;
        loop: {
        {% for i in range(70) %}
            if ({{i}} >= robots.length) break loop;
            robot = robots[{{i}}];
            if (robot.team == rc.getTeam() && robot.paintAmount > 0 && isTower(robot.type)) {
                home = robot.location;
                break loop;
            }
        {% endfor %}
        }
    }

    public static void refuel() throws GameActionException {
        Pathing.pathTo(home);
        if (rc.canSenseLocation(home)) {
            RobotInfo r = rc.senseRobotAtLocation(home);
            int amt = Math.max(myPaint - paintCapacity, -r.getPaintAmount());
            if (rc.canTransferPaint(home, amt)) {
                rc.transferPaint(home, amt);
            }
        }
    }

    public static MapLocation seeRuin() throws GameActionException {
        MapLocation closest = null;
        int lowest = 10000000;
        for (int i = near.length; --i >= 0; ) {
            if (near[i].hasRuin()) {
                RobotInfo r = rc.senseRobotAtLocation(near[i].getMapLocation());
                if (r == null) {
                    MapLocation loc = near[i].getMapLocation();
                    int d = loc.distanceSquaredTo(rc.getLocation());
                    if (d < lowest) {
                        lowest = d;
                        closest = loc;
                    }
                }
            }
        }
        return closest;
    }

    public static UnitType getTowerToBuild() throws GameActionException {
        if (rc.getNumberTowers() < 3) return UnitType.LEVEL_ONE_MONEY_TOWER;
        return UnitType.LEVEL_ONE_PAINT_TOWER;
    }

    public static void makeTower() throws GameActionException {
        assert(buildTower != null);
        {# if (patternLaid && buildExploreTurns > 0) {
            Explore.exploreOutOfVision(buildTower);
            --buildExploreTurns;
            return;
        } #}
        if (rc.getLocation().distanceSquaredTo(buildTower) >= 4) {
            Pathing.pathTo(buildTower);
            return;
        }

        UnitType t = getTowerToBuild();
        MapLocation check = buildTower.add(buildTower.directionTo(rc.getLocation()));
        boolean towerPatternMarked = (rc.senseMapInfo(check).getMark() != PaintType.EMPTY);
        if (!towerPatternMarked && rc.canMarkTowerPattern(t, buildTower)) {
            rc.markTowerPattern(t, buildTower);
        }

        int saw = 0;
        int correct = 0;
        MapLocation goal = null;
        boolean secondCol = false;
        int bestDist = 1000000000;
        for (int i = 3; --i >= -2; ){
            for (int j = 3; --j >= -2; ){
                if (i == 0 && j == 0) continue;
                MapLocation tmp = new MapLocation(buildTower.x + i, buildTower.y + j);
                if (rc.canSenseLocation(tmp)) {
                    ++saw;
                    MapInfo mi = rc.senseMapInfo(tmp);
                    if (mi.getMark() != mi.getPaint() && mi.getMark() != PaintType.EMPTY && canChangeColor(mi)) {
                        int d = rc.getLocation().distanceSquaredTo(tmp);
                        if (d < bestDist) {
                            bestDist = d;
                            goal = tmp;
                            secondCol = mi.getMark() == PaintType.ALLY_SECONDARY;
                        }
                    } else {
                        ++correct;
                    }
                }
            }
        }
        if (goal != null) {
            if (rc.canAttack(goal)) {
                rc.attack(goal, secondCol);
            } else {
                Pathing.pathTo(goal);
            }
        } else {
            if (saw == 24 && correct == 24 && patternLaid == false) {
                buildExploreTurns = 10;
                patternLaid = true;
            }
            if (rc.canCompleteTowerPattern(UnitType.LEVEL_ONE_PAINT_TOWER, buildTower)){
                rc.completeTowerPattern(UnitType.LEVEL_ONE_PAINT_TOWER, buildTower);
                removing = buildTower;
                removeMask = (1 << 25) - 1;
                resetBuild();
            } else if (rc.canCompleteTowerPattern(UnitType.LEVEL_ONE_MONEY_TOWER, buildTower)){
                rc.completeTowerPattern(UnitType.LEVEL_ONE_MONEY_TOWER, buildTower);
                removing = buildTower;
                removeMask = (1 << 25) - 1;
                resetBuild();
            }
        }
    }

    public static boolean isBuilt(MapLocation ruinLoc) throws GameActionException {
        if (rc.canSenseLocation(ruinLoc)) {
            RobotInfo r = rc.senseRobotAtLocation(ruinLoc);
            return (r != null);
        }
        return false;
    }

    public static void moneyPattern() throws GameActionException {
        //make sure we see no ruins
        //and make sure nothing in the 5 by 5 is marked
        if (ruinLoc != null && rc.getNumberTowers() < 25) return;
        if (rc.getPaint() < 20) return;
        if (rc.getNumberTowers() < 4) return;
        boolean bad = false;
        for (int i = 3; --i >= -2; ){
            if (bad) break;
            for (int j = 3; --j >= -2; ){
                MapLocation tmp = new MapLocation(rc.getLocation().x + i, rc.getLocation().y + j);
                if (rc.canSenseLocation(tmp)) {
                    MapInfo mi = rc.senseMapInfo(tmp);
                    if (mi.getMark() != PaintType.EMPTY) {
                        if (resourcePat[i + 2][j + 2] != (mi.getMark() == PaintType.ALLY_SECONDARY)) {
                            bad = true;
                            break;
                        }
                    }
                }
                else {
                    bad = true;
                    break;
                }
            }
        }
        if (!bad) {
            //i think this check can probably be removed...
            if (rc.canMarkResourcePattern(rc.getLocation())) {
                rc.markResourcePattern(rc.getLocation());
                markedResource = rc.getLocation();
            }
        }
    }

    public static boolean paintMarkedSquares() throws GameActionException {
        if (rc.getPaint() < 20) return false;
        MapLocation goal = null;
        int bestDist = 1000000000;
        boolean secondCol = false;
        for (int i = near.length; --i >= 0; ) {
            if (near[i].getMark() != PaintType.EMPTY && near[i].getMark() != near[i].getPaint() && canChangeColor(near[i])) {
                int d = rc.getLocation().distanceSquaredTo(near[i].getMapLocation());
                if (d < bestDist) {
                    bestDist = d;
                    goal = near[i].getMapLocation();
                    secondCol = (near[i].getMark() == PaintType.ALLY_SECONDARY);
                }
            }
        }
        if (goal != null) {
            if (rc.canAttack(goal)) {
                rc.attack(goal, secondCol);
            }
            else {
                Pathing.pathTo(goal);
            }
            return true;
        }
        return false;
    }

    public static boolean seeIncompleteRuin(MapLocation ruin) throws GameActionException {
        for (int i = 3; --i >= -2; ){
            for (int j = 3; --j >= -2; ){
                if (i == 0 && j == 0) continue;
                MapLocation tmp = new MapLocation(ruin.x + i, ruin.y + j);
                if (rc.canSenseLocation(tmp)) {
                    MapInfo mi = rc.senseMapInfo(tmp);
                    if ((mi.getMark() != mi.getPaint() || mi.getMark() == PaintType.EMPTY) && canChangeColor(mi)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public static void makeResourcePatch() throws GameActionException {
        Pathing.pathTo(markedResource);
        MapLocation goal = null;
        int bestDist = 1000000000;
        boolean secondCol = false;
        for (int i = 3; --i >= -2; ){
            for (int j = 3; --j >= -2; ){
                if (i == 0 && j == 0) continue;
                MapLocation tmp = new MapLocation(markedResource.x + i, markedResource.y + j);
                if (rc.canSenseLocation(tmp)) {
                    MapInfo mi = rc.senseMapInfo(tmp);
                    if (mi.getMark() != mi.getPaint() && mi.getMark() != PaintType.EMPTY && canChangeColor(mi)) {
                        int d = rc.getLocation().distanceSquaredTo(tmp);
                        if (d < bestDist) {
                            bestDist = d;
                            goal = tmp;
                            secondCol = (mi.getMark() == PaintType.ALLY_SECONDARY);
                        }
                    }
                }
            }
        }
        if (goal != null) {
            if (rc.canAttack(goal)) {
                rc.attack(goal, secondCol);
            }
        }
        if (rc.canCompleteResourcePattern(markedResource)) {
            rc.completeResourcePattern(markedResource);
            markedResource = null;
        }
    }

    public static void removePattern() throws GameActionException {
        MapLocation goal = removing;
        for (int i = 3; --i >= -2; ){
            for (int j = 3; --j >= -2; ){
                if (i == 0 && j == 0) continue;
                MapLocation tmp = new MapLocation(removing.x + i, removing.y + j);
                int v = (i + 2) * 5 + (j + 2);
                if ((removeMask & (1 << v)) != 0) {
                    if (rc.canRemoveMark(tmp)) {
                        removeMask ^= (1 << v);
                        rc.removeMark(tmp);
                    }
                    else if (v != 12) {
                        goal = tmp;
                    }
                }
            }
        }
        if (removeMask == (1 << 12)) {
            removing = null;
            removeMask = 0;
        }
        else {
            Pathing.pathTo(goal);
        }
    }

    public static void updateBuild() throws GameActionException {
        if (rc.senseNearbyRobots(9, rc.getTeam()).length >= 1) {
            resetBuild();
            return;
        }
        {# int soldierCount = 0;
        for (RobotInfo r: rc.senseNearbyRobots(9, rc.getTeam())) {
            if (r.type == UnitType.SOLDIER) soldierCount++;
        }
        if (soldierCount != 0) {
            resetBuild();
            return;
        } #}

        if (buildTower != null) {
            if (rc.canSenseLocation(buildTower) && rc.senseRobotAtLocation(buildTower) != null) {
                resetBuild();
            }
            return;
        }

        ruinLoc = seeRuin();
        if (ruinLoc == null) {
            resetBuild();
            return;
        }

        // Make sure we're the only ones trying to build this.
        {# MapLocation closest = rc.getLocation();
        int closestDistance = closest.distanceSquaredTo(ruinLoc);
        for (RobotInfo r: rc.senseNearbyRobots(ruinLoc, 4, rc.getTeam())) {
            if (r.type == UnitType.SOLDIER) {
                int d = ruinLoc.distanceSquaredTo(r.location);
                if (d < closestDistance) {
                    closestDistance = d;
                    closest = r.location;
                }
            }
        } #}
        if (closest.equals(rc.getLocation())) {
            buildTower = ruinLoc;
            return;
        }
        resetBuild();
    }

    public static void resetBuild() throws GameActionException {
        buildTower = null;
        patternLaid = false;
        buildExploreTurns = 0;
    }
}