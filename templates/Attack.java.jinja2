package current;
import battlecode.common.*;

{% set dirY = [1, 1, 0, -1, -1, -1,  0,  1, 0] %}
{% set dirX = [0, 1, 1,  1,  0, -1, -1, -1, 0] %}

public class Attack {
    public static RobotController rc;

    {% set copiedAttributes = ['actionRadiusSquared', 'paintCapacity', 'actionCooldown', 'attackStrength', 'aoeAttackStrength']%}
    {% for unit in ['soldier', 'splasher'] -%}
    {% for attribute in copiedAttributes -%}
    public static int {{unit}}{{capitalizeFirstLetter(attribute)}};
    {% endfor -%}
    {% endfor -%}

    public static void init(RobotController rc) {
        Attack.rc = rc;
        {% for unit in ['soldier', 'splasher'] -%}
        {% for attribute in copiedAttributes -%}
        {{unit}}{{capitalizeFirstLetter(attribute)}} = UnitType.{{unit.upper()}}.{{attribute}};
        {% endfor -%}
        {% endfor %}

        splasherActionRadiusSquared = 9;
    }

    public static boolean shouldSoldierMicro() throws GameActionException {
        for (int i = Globals.enemies.length; --i >= 0; ) {
            switch (Globals.enemies[i].type) {
                case SOLDIER, MOPPER, SPLASHER: continue;
                default: return true;
            }
        }
        return false;
    }

    public static void soldierTryAttack() throws GameActionException {
        for (int i = Globals.enemies.length; --i >= 0;) {
            RobotInfo enemy = Globals.enemies[i];
            switch (enemy.type) {
                case SOLDIER, SPLASHER, MOPPER: continue;
                default: {
                    MapLocation loc = enemy.location;
                    if (rc.canAttack(loc)) {
                        rc.attack(loc);
                        return;
                    }
                }
            }
        }
    }

    public static boolean shouldSplasherMicro() throws GameActionException {
        // Only activate micro if you can attack a tower.
        for (int i = Globals.enemies.length; --i >= 0; ) {
            switch (Globals.enemies[i].type) {
                case SOLDIER, MOPPER, SPLASHER: continue;
                default: return true;
            }
        }
        return false;
    }

    public static void splasherTryAttack() throws GameActionException {}

    public static void _splasherTryAttack() throws GameActionException {
        if (!rc.isActionReady() || rc.getPaint() < (UnitType.SPLASHER.paintCapacity >> 2)) return;
        MapLocation myloc = rc.getLocation();
        int x = myloc.x, y = myloc.y;
        MapLocation bestLoc = null;
        int count = 0, bestCount = -1;

        {% for i in range(-3, 4, 1) %}
        {% for j in range(-3, 4, 1) %}
        MapLocation mloc{{i+3}}{{j+3}} = new MapLocation(x + {{ i }}, y + {{ j }});
        boolean hasTower{{i+3}}{{j+3}} = false;
        if (rc.canSenseLocation(mloc{{i+3}}{{j+3}})) {
            RobotInfo r{{i+3}}{{j+3}} = rc.senseRobotAtLocation(mloc{{i+3}}{{j+3}});
            if ( r{{i+3}}{{j+3}} != null &&  r{{i+3}}{{j+3}}.team != rc.getTeam() && Globals.isTower(r{{i+3}}{{j+3}}.type)) {
                hasTower{{i+3}}{{j+3}} = true;
            }
        }
        {% endfor %}
        {% endfor %}

        {% for i in range(-2, 3, 1) %}
        {% for j in range(-2, 3, 1) %}
        if (rc.canAttack(mloc{{i+3}}{{j+3}})) {
            count = 0;
            {% for k in range(-1, 2, 1) %}
            {% for l in range(-1, 2, 1) %} 
            if (hasTower{{i+k+3}}{{j+l+3}}) ++count;
            {% endfor %}
            {% endfor %}
            if (count > bestCount) {
                bestLoc = mloc{{i+3}}{{j+3}};
                bestCount = count;
            }
        }
        {% endfor %}
        {% endfor %}

        if (bestCount >= 1) {
            rc.attack(bestLoc);
        }
    }
    
    {% macro attackMicro(type) -%}
    public static void {{type}}AttackMicro() throws GameActionException {
        {{type}}TryAttack();
        MapLocation myloc = rc.getLocation();
        SquareManager.computePaintPenalties();
        {% for i in range(9) -%}
        {{ initTarget(type, i) | indent(4) }}
        {%- endfor -%}

        boolean actionReady = rc.isActionReady();
        for (int i = Globals.friends.length; --i >= 0; ) {
            RobotInfo robot = Globals.friends[i];
            {% for i in range(9) -%}
            {{ addAlly(type, i) | indent(8) -}}
            {% endfor %}
        }

        for (int i = Globals.enemies.length; --i >= 0; ) {
            RobotInfo robot = Globals.enemies[i];
            {% for i in range(9) -%}
            {{ addEnemy(type, i) | indent(8) -}}
            {% endfor %}
        }

        {# {% for i in range(0, 9) -%}
        {% set dir = shortDirections[i] %}
        {% debug('minDistToEnemy_' ~ dir, 'targetLoc_' ~ dir ~ '.x', 'canMove_' ~ dir,
                 'targetLoc_' ~ dir ~ '.y', 'penalty_' ~ dir, 'healthDmgAttackRange_' ~ dir,
                 'myHealthDmg_' ~ dir) %}
        {% endfor %} #}

        boolean bestWins = false;
        Direction bestDir = {{ directions[0] }};
        {{ initTargetWithSuffix(type, i=0, suffix='best') | indent(4) }}
        
        {{ copy(type, 'best', shortDirections[0]) | indent(4) -}}
        {% for i in range(1, 9) -%}
        {{ chooseBest(type, i) | indent(4) }}
        {% endfor %}

        {# {% set dir = 'best' %}
        {% debug('minDistToEnemy_' ~ dir, 'targetLoc_' ~ dir ~ '.x', 'canMove_' ~ dir,
                 'targetLoc_' ~ dir ~ '.y', 'penalty_' ~ dir, 'healthDmgAttackRange_' ~ dir,
                 'myHealthDmg_' ~ dir) %}
        System.out.println("Chose: " + bestDir);
        System.out.println("\n"); #}

        if (rc.canMove(bestDir)) {
            rc.move(bestDir);
        }
        {{type}}TryAttack();
    }
    {% endmacro -%}

    /*------------------ CHOOSE BEST --------------------*/
    {%- macro chooseBest(type, i) -%}
    {%- set best = 'best' -%}
    {%- set dir = shortDirections[i] -%}
    {%- set label = 'chooseBest' ~ _ ~ dir %}
    bestWins = canMove_{{best}};
    {{label}}: {
        if (!canMove_{{dir}} || !canMove_{{best}}) break {{label}};
        double bestHealthDmgDiff = healthDmgAttackRange_{{best}} - myHealthDmg_{{best}};
        double otherHealthDmgDiff = healthDmgAttackRange_{{dir}} - myHealthDmg_{{dir}};
        if (bestHealthDmgDiff != otherHealthDmgDiff) {
            bestWins = (bestHealthDmgDiff < otherHealthDmgDiff);
            break {{label}};
        }

        if (minDistToEnemy_{{best}} != minDistToEnemy_{{dir}}) {
            bestWins = (minDistToEnemy_{{best}} < minDistToEnemy_{{dir}});
            break {{label}};
        }

        bestWins = penalty_{{best}} <= penalty_{{dir}};
        break {{label}};
    }
    {# We can get rid of the copy if we use a switch.  #}
    {# Just trying to get something down at the moment. #}
    if (!bestWins) {
        {{ copy(type, 'best', dir) | indent(4) -}}
        bestDir = {{ directions[i] }};
    }
    {% endmacro -%}
    /* ################## CHOOSE BEST #################### */


    /*------------------ ADD ALLY --------------------*/
    {%- macro addAlly(type, i) -%}
    {%- set robotVar = 'robot' -%}
    {%- set dir = shortDirections[i] -%}
    {%- set label = 'addAlly' ~ _ ~ dir -%}
    {{label}}: {
        {# if (!canMove_{{ dir }}) break {{label}};
        int d = targetLoc_{{dir}}.distanceSquaredTo({{robotVar}}.location); #}
    }
    {% endmacro -%}
    /* ################## ADD ALLY #################### */

    /*------------------ ADD ENEMY --------------------*/
    {# TODO: Factor into seperate pieces for each unit. #}
    {%- macro addEnemy(type, i) -%}
    {%- set robotVar = 'robot' -%}
    {%- set dir = shortDirections[i] -%}
    {%- set label = 'addEnemy' ~ _ ~ dir %}
    {{label}}: {
        if (!canMove_{{dir}}) break {{label}};
        int d = targetLoc_{{dir}}.distanceSquaredTo({{robotVar}}.location);
        switch (robot.type) {
            {% for tower in [
                'LEVEL_ONE_DEFENSE_TOWER', 'LEVEL_ONE_MONEY_TOWER', 'LEVEL_ONE_PAINT_TOWER',
                'LEVEL_THREE_DEFENSE_TOWER', 'LEVEL_THREE_MONEY_TOWER', 'LEVEL_THREE_PAINT_TOWER',
                'LEVEL_TWO_DEFENSE_TOWER', 'LEVEL_TWO_MONEY_TOWER', 'LEVEL_TWO_PAINT_TOWER'] -%}
            case {{tower}}: {
                {% if type == 'soldier' %}
                if (actionReady && d <= {{type}}ActionRadiusSquared) {
                    myHealthDmg_{{dir}} = {{type}}AttackStrength;
                }
                {% endif %}
                if (d <= UnitType.{{tower}}.actionRadiusSquared) {
                    // Should have another one for AOE damage.
                    healthDmgAttackRange_{{dir}} += UnitType.{{tower}}.attackStrength;
                }
                if (d < minDistToEnemy_{{dir}}) minDistToEnemy_{{dir}} = d;
                break {{label}};
            }
            {% endfor %}
            default: break {{label}};
        }
    }
    {% endmacro %}
    /* ################## ADD ENEMY #################### */

    /*------------------ INIT TARGET --------------------*/
    {%- macro initTarget(type, i) -%}
    {{ initTargetWithSuffix(type, i=i, suffix=shortDirections[i]) }}
    {% endmacro -%}

    {%- macro initTargetWithSuffix(type, i, suffix) -%}
    {%- set dir = directions[i] -%}
    {%- set val = 'true' if dir == 'Direction.CENTER' else ('rc.canMove(' ~ dir ~ ')' ) -%}
    MapLocation targetLoc_{{suffix}} = SquareManager.m{{dirX[i]+2}}{{dirY[i]+2}};
    boolean canMove_{{suffix}} = ({{val}});
    double healthDmgAttackRange_{{suffix}} = 0;
    double myHealthDmg_{{suffix}} = 0;
    int minDistToEnemy_{{suffix}} = 100000;
    int penalty_{{suffix}} = SquareManager.penalty{{dirX[i]+2}}{{dirY[i]+2}};
    {% endmacro -%}
    /* ################## INIT TARGET #################### */
    
    /*------------------ COPY --------------------*/
    {# WARNING THIS MUST BE UPDATED OR MICRO WILL HAVE BUGS #}
    {%- macro copy(type, dest, src) -%}
    {%- for attribute in ['targetLoc', 'canMove', 'healthDmgAttackRange', 'myHealthDmg', 'minDistToEnemy', 'penalty'] -%}
    {{attribute}}_{{dest}} = {{attribute}}_{{src}};
    {% endfor -%}
    {% endmacro -%}
    /* ################## COPY #################### */

    {% for type in ['soldier', 'splasher'] %}
    {{ attackMicro(type) }}
    {% endfor %}

}