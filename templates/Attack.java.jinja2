package current;
import battlecode.common.*;

public class Attack {
    public static RobotController rc;

    {% set copiedAttributes = ['actionRadiusSquared', 'paintCapacity', 'actionCooldown', 'attackStrength']%}
    {% for unit in ['soldier', 'splasher', 'mopper'] -%}
    {% for attribute in copiedAttributes -%}
    public static int {{unit}}{{capitalizeFirstLetter(attribute)}};
    {% endfor -%}
    {% endfor -%}

    public static void init(RobotController rc) {
        Attack.rc = rc;
        {% for unit in ['soldier', 'splasher', 'mopper'] -%}
        {% for attribute in copiedAttributes -%}
        {{unit}}{{capitalizeFirstLetter(attribute)}} = UnitType.{{unit.upper()}}.{{attribute}};
        {% endfor -%}
        {% endfor %}
    }

    public static boolean shouldSoldierMicro() throws GameActionException {
        for (int i = Globals.enemies.length; --i >= 0; ) {
            switch (Globals.enemies[i].type) {
                case SOLDIER, MOPPER, SPLASHER: continue;
                default: return true;
            }
        }
        return false;
    }

    public static void soldierTryAttack() throws GameActionException {
        for (int i = Globals.enemies.length; --i >= 0;) {
            RobotInfo enemy = Globals.enemies[i];
            switch (enemy.type) {
                case SOLDIER, SPLASHER, MOPPER: continue;
                default: {
                    MapLocation loc = enemy.location;
                    if (rc.canAttack(loc)) {
                        rc.attack(loc);
                        return;
                    }
                }
            }
        }
    }

    public static boolean shouldSplasherMicro() throws GameActionException {
        // Only activate micro if you can attack a tower.
        for (int i = Globals.enemies.length; --i >= 0; ) {
            switch (Globals.enemies[i].type) {
                case SOLDIER, MOPPER, SPLASHER: continue;
                default: return true;
            }
        }
        return false;
    }

    public static void splasherTryAttack() throws GameActionException {
        // Not quite correct, we should choose the best spot nearby.
        for (int i = Globals.enemies.length; --i >= 0;) {
            RobotInfo enemy = Globals.enemies[i];
            switch (enemy.type) {
                case SOLDIER, SPLASHER, MOPPER: continue;
                default: {
                    MapLocation loc = enemy.location;
                    if (rc.canAttack(loc)) {
                        rc.attack(loc);
                        return;
                    }
                }
            }
        }
    }

    public static boolean shouldMopperMicro() throws GameActionException {
        for (int i = Globals.enemies.length; --i >= 0; ) {
            switch (Globals.enemies[i].type) {
                case SOLDIER, MOPPER, SPLASHER: {
                    if (Globals.enemies[i].paintAmount != 0) return true;
                };
                default: continue;
            }
        }
        return false;
    }

    public static void mopperTryAttack() throws GameActionException {
        MapLocation bestThreatLoc = null;
        int smallestThreatPaint = 100000000;
        MapLocation bestNonThreatLoc = null;
        int smallestNonThreatPaint = 100000000;
        for (int i = Globals.enemies.length; --i >= 0;) {
            RobotInfo enemy = Globals.enemies[i];
            if (enemy.paintAmount == 0) continue;
            MapLocation loc = enemy.location;
            switch (enemy.type) {
                case MOPPER, SPLASHER -> {
                    if (rc.canAttack(loc) && enemy.paintAmount < smallestThreatPaint) {
                        bestThreatLoc = loc;
                        smallestThreatPaint = enemy.paintAmount;
                    }
                }
                case SOLDIER -> {
                    if (rc.canAttack(loc) && enemy.paintAmount < smallestNonThreatPaint) {
                        bestNonThreatLoc = loc;
                        smallestNonThreatPaint = enemy.paintAmount;
                    }
                }
                default -> {}
            }
        }

        if (bestThreatLoc != null) {
            rc.setIndicatorString("Attacking Threat!");
            rc.setIndicatorDot(bestThreatLoc, 0, 0, 0);
            rc.attack(bestThreatLoc);
        } else if (bestNonThreatLoc != null) {
            rc.setIndicatorString("Attacking Normal!");
            rc.setIndicatorDot(bestNonThreatLoc, 0, 0, 0);
            rc.attack(bestNonThreatLoc);
        } else {
            rc.setIndicatorString("Didn't Attack!");
        }
    }
    
    {% macro attackMicro(type) -%}
    public static void {{type}}AttackMicro() throws GameActionException {
        {{type}}TryAttack();
        MapLocation myloc = rc.getLocation();
        {% for i in range(9) -%}
        {{ initTarget(type, i) | indent(4) }}
        {%- endfor -%}

        boolean actionReady = rc.isActionReady();
        for (int i = Globals.friends.length; --i >= 0; ) {
            RobotInfo robot = Globals.friends[i];
            {% for i in range(9) -%}
            {{ addAlly(type, i) | indent(8) -}}
            {% endfor %}
        }

        for (int i = Globals.enemies.length; --i >= 0; ) {
            RobotInfo robot = Globals.enemies[i];
            {% for i in range(9) -%}
            {{ addEnemy(type, i) | indent(8) -}}
            {% endfor %}
        }

        {# {% for i in range(0, 9) -%}
        {% set dir = shortDirections[i] %}
        {% debug('minDistToEnemy_' ~ dir, 'targetLoc_' ~ dir ~ '.x', 'canMove_' ~ dir,
                 'targetLoc_' ~ dir ~ '.y', 'myPaintDmg_' ~ dir, 'paintDmgAttackRange_' ~ dir) %}
        {% endfor %} #}

        boolean bestWins = false;
        Direction bestDir = {{ directions[0] }};
        {{ initTargetWithSuffix(type, dir=directions[0], suffix='best') | indent(4) }}
        {% for i in range(1, 9) -%}
        {{ chooseBest(type, i) | indent(4) }}
        {% endfor %}

        {# {% set dir = 'best' %}
        {% debug('minDistToEnemy_' ~ dir, 'targetLoc_' ~ dir ~ '.x', 'canMove_' ~ dir,
                 'targetLoc_' ~ dir ~ '.y', 'myPaintDmg_' ~ dir, 'paintDmgAttackRange_' ~ dir) %}
        System.out.println("\n"); #}

        if (rc.canMove(bestDir)) {
            rc.move(bestDir);
        }
        {{type}}TryAttack();
    }
    {% endmacro -%}

    /*------------------ CHOOSE BEST --------------------*/
    {%- macro chooseBest(type, i) -%}
    {%- set best = 'best' -%}
    {%- set dir = shortDirections[i] -%}
    {%- set label = 'chooseBest' ~ _ ~ dir %}
    bestWins = canMove_{{best}};
    {{label}}: {
        if (!canMove_{{dir}} || !canMove_{{best}}) break {{label}};
        double bestHealthDmgDiff = healthDmgAttackRange_{{best}} - myHealthDmg_{{best}};
        double otherHealthDmgDiff = healthDmgAttackRange_{{dir}} - myHealthDmg_{{dir}};
        if (bestHealthDmgDiff != otherHealthDmgDiff) {
            bestWins = (bestHealthDmgDiff < otherHealthDmgDiff);
            break {{label}};
        }
        if (paint_{{best}}.isAlly() != paint_{{dir}}.isAlly()) {
            bestWins = paint_{{best}}.isAlly();
            break {{label}};
        }
        bestWins = (minDistToEnemy_{{best}} <= minDistToEnemy_{{dir}});
        break {{label}};
    }
    {# We can get rid of the copy if we use a switch.  #}
    {# Just trying to get something down at the moment. #}
    if (!bestWins) {
        {{ copy(type, 'best', dir) | indent(4) -}}
        bestDir = {{ directions[i] }};
    }
    {% endmacro -%}
    /* ################## CHOOSE BEST #################### */


    /*------------------ ADD ALLY --------------------*/
    {%- macro addAlly(type, i) -%}
    {%- set robotVar = 'robot' -%}
    {%- set dir = shortDirections[i] -%}
    {%- set label = 'addAlly' ~ _ ~ dir -%}
    {{label}}: {
        {# if (!canMove_{{ dir }}) break {{label}};
        int d = targetLoc_{{dir}}.distanceSquaredTo({{robotVar}}.location); #}
    }
    {% endmacro -%}
    /* ################## ADD ALLY #################### */

    /*------------------ ADD ENEMY --------------------*/
    {# TODO: Factor into seperate pieces for each unit. #}
    {%- macro addEnemy(type, i) -%}
    {%- set robotVar = 'robot' -%}
    {%- set dir = shortDirections[i] -%}
    {%- set label = 'addEnemy' ~ _ ~ dir %}
    {{label}}: {
        if (!canMove_{{dir}}) break {{label}};
        int d = targetLoc_{{dir}}.distanceSquaredTo({{robotVar}}.location);
        switch (robot.type) {
            {% for tower in [
                'LEVEL_ONE_DEFENSE_TOWER', 'LEVEL_ONE_MONEY_TOWER', 'LEVEL_ONE_PAINT_TOWER',
                'LEVEL_THREE_DEFENSE_TOWER', 'LEVEL_THREE_MONEY_TOWER', 'LEVEL_THREE_PAINT_TOWER',
                'LEVEL_TWO_DEFENSE_TOWER', 'LEVEL_TWO_MONEY_TOWER', 'LEVEL_TWO_PAINT_TOWER'] -%}
            case {{tower}}: {
                if (actionReady && d <= {{type}}ActionRadiusSquared) {
                    myHealthDmg_{{dir}} = {{type}}AttackStrength;
                }
                if (d <= UnitType.{{tower}}.actionRadiusSquared) {
                    // Should have another one for AOE damage.
                    healthDmgAttackRange_{{dir}} += UnitType.{{tower}}.attackStrength;
                }
                if (d < minDistToEnemy_{{dir}}) minDistToEnemy_{{dir}} = d;
                break {{label}};
            }
            {% endfor %}
            default: break {{label}};
        }
    }
    {% endmacro %}
    /* ################## ADD ENEMY #################### */

    /* TODO: Allow moving on enemy paint? */
    /*------------------ INIT TARGET --------------------*/
    {%- macro initTarget(type, i) -%}
    {{ initTargetWithSuffix(type, dir=directions[i], suffix=shortDirections[i]) }}
    {% endmacro -%}

    {%- macro initTargetWithSuffix(type, dir, suffix) -%}
    {%- set val = 'true' if dir == 'Direction.CENTER' else ('rc.canMove(' ~ dir ~ ')' ) -%}
    MapLocation targetLoc_{{suffix}} = myloc.add({{ dir }});
    boolean canMove_{{suffix}} = ({{val}});
    PaintType paint_{{suffix}} = PaintType.ENEMY_PRIMARY;
    if (rc.canSenseLocation(targetLoc_{{suffix}})) {
        paint_{{suffix}} = rc.senseMapInfo(targetLoc_{{suffix}}).getPaint();
        switch (rc.senseMapInfo(targetLoc_{{suffix}}).getPaint()) {
             case PaintType.ENEMY_PRIMARY -> canMove_{{suffix}} = false;
             case PaintType.ENEMY_SECONDARY -> canMove_{{suffix}} = false;
             default -> {}
        }
    }
    double healthDmgAttackRange_{{suffix}} = 0;
    double myHealthDmg_{{suffix}} = 0;
    int minDistToEnemy_{{suffix}} = 100000;
    {% endmacro -%}
    /* ################## INIT TARGET #################### */
    
    /*------------------ COPY --------------------*/
    {# WARNING THIS MUST BE UPDATED OR MICRO WILL HAVE BUGS #}
    {%- macro copy(type, dest, src) -%}
    {%- for attribute in ['targetLoc', 'canMove', 'healthDmgAttackRange', 'myHealthDmg', 'minDistToEnemy', 'paint'] -%}
    {{attribute}}_{{dest}} = {{attribute}}_{{src}};
    {% endfor -%}
    {% endmacro -%}
    /* ################## COPY #################### */

    {% for type in ['soldier', 'splasher', 'mopper'] %}
    {{ attackMicro(type) }}
    {% endfor %}

}